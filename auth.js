const express = require('express'), router = express.Router(), bcrypt = require('bcryptjs'), jwt = require('jsonwebtoken'), { v4: uuidv4 } = require('uuid'), db = require('../config/database'), { authenticateToken } = require('../middleware/auth'), rateLimit = require('express-rate-limit');
const loginLimiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 5, message: { error: 'Troppi tentativi di login riprova tra 15 minuti.' }, standardHeaders: true, legacyHeaders: false });
const refreshLimiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 10, message: { error: 'Troppi tentativi di refresh riprova più tardi.' } });

router.post('/register', authenticateToken, async (req, res) => { try { const { username, password, user_type } = req.body; if (req.user.user_type_code !== 'ADMIN') return res.status(403).json({ error: 'Non autorizzato' }); if (!username || !password || !user_type) return res.status(400).json({ error: 'Username, password e tipo utente sono obbligatori' }); if (username.length < 3 || username.length > 50) return res.status(400).json({ error: 'Username deve essere tra 3 e 50 caratteri' }); if (password.length < 6) return res.status(400).json({ error: 'Password deve essere almeno 6 caratteri' }); if (!['USER', 'ADMIN'].includes(user_type)) return res.status(400).json({ error: 'Tipo utente non valido' }); const [existingUsers] = await db.query('SELECT id FROM user WHERE username = ?', [username]); if (existingUsers.length > 0) return res.status(400).json({ error: 'Username già esistente' }); const password_hash = await bcrypt.hash(password, 10); const [userTypes] = await db.query('SELECT id FROM user_type WHERE code = ?', [user_type]); if (userTypes.length === 0) return res.status(500).json({ error: 'Tipo utente non trovato nel sistema' }); const [result] = await db.query('INSERT INTO user (username, password_hash, user_type_id) VALUES (?, ?, ?)', [username, password_hash, userTypes[0].id]); res.status(201).json({ message: 'Utente registrato con successo', user_id: result.insertId }); } catch (error) { res.status(500).json({ error: 'Errore durante la registrazione' }); } });
router.post('/login', loginLimiter, async (req, res) => { try { const { username, password } = req.body; if (!username || !password) return res.status(400).json({ error: 'Credenziali non valide' }); const [users] = await db.query('SELECT u.id, u.username, u.password_hash, u.is_active, ut.code as user_type_code FROM user u JOIN user_type ut ON u.user_type_id = ut.id WHERE u.username = ?', [username]); if (users.length === 0) return res.status(401).json({ error: 'Credenziali non valide' }); const user = users[0]; if (!user.is_active) return res.status(401).json({ error: 'Credenziali non valide' }); const passwordMatch = await bcrypt.compare(password, user.password_hash); if (!passwordMatch) return res.status(401).json({ error: 'Credenziali non valide' }); const accessToken = jwt.sign({ id: user.id, username: user.username, user_type_code: user.user_type_code }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_ACCESS_EXPIRATION }); const jti = uuidv4(), refreshToken = jwt.sign({ id: user.id, jti }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_REFRESH_EXPIRATION }); const tokenHash = await bcrypt.hash(refreshToken, 10), expiresAt = new Date(); expiresAt.setDate(expiresAt.getDate() + 7); await db.query('INSERT INTO jwt (user_id, jti, token_hash, expires_at) VALUES (?, ?, ?, ?)', [user.id, jti, tokenHash, expiresAt]); res.json({ accessToken, refreshToken, user: { id: user.id, username: user.username, user_type: user.user_type_code } }); } catch (error) { res.status(500).json({ error: 'Errore durante il login' }); } });
router.post('/refresh', refreshLimiter, async (req, res) => { try { const { refreshToken } = req.body; if (!refreshToken) return res.status(401).json({ error: 'Refresh token mancante' }); let decoded; try { decoded = jwt.verify(refreshToken, process.env.JWT_SECRET); } catch (error) { return res.status(403).json({ error: 'Refresh token non valido' }); } const [tokens] = await db.query('SELECT t.*, u.username, ut.code as user_type_code FROM jwt t JOIN user u ON t.user_id = u.id JOIN user_type ut ON u.user_type_id = ut.id WHERE t.jti = ? AND t.revoked_at IS NULL AND t.expires_at > NOW()', [decoded.jti]); if (tokens.length === 0) return res.status(403).json({ error: 'Refresh token non valido o revocato' }); const tokenData = tokens[0], tokenMatch = await bcrypt.compare(refreshToken, tokenData.token_hash); if (!tokenMatch) return res.status(403).json({ error: 'Refresh token non valido' }); const newAccessToken = jwt.sign({ id: tokenData.user_id, username: tokenData.username, user_type_code: tokenData.user_type_code }, process.env.JWT_SECRET, { expiresIn: process.env.JWT_ACCESS_EXPIRATION }); res.json({ accessToken: newAccessToken }); } catch (error) { res.status(500).json({ error: 'Errore durante il refresh del token' }); } });
router.post('/logout', authenticateToken, async (req, res) => { try { const { refreshToken } = req.body; if (!refreshToken) return res.status(400).json({ error: 'Refresh token mancante' }); const decoded = jwt.decode(refreshToken); if (!decoded || !decoded.jti) return res.status(400).json({ error: 'Token non valido' }); await db.query('UPDATE jwt SET revoked_at = NOW() WHERE jti = ? AND user_id = ?', [decoded.jti, req.user.id]); res.json({ message: 'Logout effettuato con successo' }); } catch (error) { res.status(500).json({ error: 'Errore durante il logout' }); } });
router.get('/me', authenticateToken, async (req, res) => { try { const [users] = await db.query('SELECT u.id, u.username, ut.code as user_type, u.created_at FROM user u JOIN user_type ut ON u.user_type_id = ut.id WHERE u.id = ?', [req.user.id]); if (users.length === 0) return res.status(404).json({ error: 'Utente non trovato' }); res.json(users[0]); } catch (error) { res.status(500).json({ error: 'Errore durante il recupero delle informazioni utente' }); } });
module.exports = router;
